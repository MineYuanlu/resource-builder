#!/usr/bin/python3
import argparse
import fnmatch
import re
import os
import sys
import subprocess
import json
from shutil import rmtree

parser = argparse.ArgumentParser(description="Arg parser")
parser.add_argument('work_dir')
args = parser.parse_args()

if not os.path.exists(args.work_dir):
    print("Working directory %s does not exist!" % args.work_dir)
    sys.exit(-1)

os.chdir(args.work_dir)

if not os.path.exists("resources.json"):
    print("Working directory %s should contain resources.json!" % args.work_dir)
    sys.exit(-1)

headerTemplate = """/**
 * THIS IS AUTOGENERATED HEADER, DO NOT MODIFY
 */

#ifndef %s_RESOURCE_BUILDER_H
#define %s_RESOURCE_BUILDER_H
#include <cstdint>

namespace ResourceBuilder {
    enum ResourceId {
        %s
    };

    const uint8_t * get_resource_data(ResourceId id);
    uint32_t get_resource_size(ResourceId id);
}
#endif //%s_RESOURCE_BUILDER_H
"""
sourceTemplate = """/**
 * THIS IS AUTOGENERATED FILE, DO NOT MODIFY
 */

#include "resource_builder/resources.h"

#ifdef __linux__

%s
const uint8_t* ResourceBuilder::get_resource_data(ResourceBuilder::ResourceId id) {
    uint8_t* starts[] = {%s};
    return starts[id];
}

uint32_t ResourceBuilder::get_resource_size(ResourceBuilder::ResourceId id) {
    uint32_t sizes[] = {%s};
    return sizes[id];
}
#endif

#ifdef _WIN32

#include <Windows.h>
#include <WinUser.h>

const uint8_t* ResourceBuilder::get_resource_data(ResourceBuilder::ResourceId id) {
    static bool is_loaded = false;
    static const char* names[] = {%s};
    static uint8_t* starts[%d];
    
    if(!is_loaded) {
        is_loaded = true;
        
        for(int i = 0; i<%d; ++i) {
            auto info = FindResourceA(nullptr, names[i], RT_RCDATA);
            starts[i] = static_cast<uint8_t*>(LoadResource(nullptr, info));
        }
    }

    return starts[id];
}

uint32_t ResourceBuilder::get_resource_size(ResourceBuilder::ResourceId id) {
    static bool is_loaded = false;
    static const char* names[] = {%s};
    static uint32_t sizes[%d];
    
    if(!is_loaded) {
        is_loaded = true;
        
        for(int i = 0; i<%d; ++i) {
            auto info = FindResourceA(nullptr, names[i], RT_RCDATA);
            sizes[i] = static_cast<uint32_t>(SizeofResource(nullptr, info));
        }
    }
    
    return sizes[id];
}
#endif

#if __APPLE__
#include <cstdio>
#include <mach-o/getsect.h>
#include <mach-o/ldsyms.h>

const uint8_t* ResourceBuilder::get_resource_data(ResourceBuilder::ResourceId id) {
    static bool is_loaded = false;
    static uint8_t* starts[%d];
    
    if(!is_loaded) {
        is_loaded = true;
        //17 would be enough since section name is only 16 bytes long
        char buf[20];
        
        for(int i = 0; i<%d; ++i) {
            sprintf(buf, "_res_sec_%%d", i);
            size_t sz;
            starts[i] = static_cast<uint8_t*>(getsectiondata(&_mh_execute_header, "binary", buf, &sz));
        }
    }

    return starts[id];
}

uint32_t ResourceBuilder::get_resource_size(ResourceBuilder::ResourceId id) {
    static bool is_loaded = false;
    static uint32_t sizes[%d];
    
    if(!is_loaded) {
        is_loaded = true;
        //17 would be enough since section name is only 16 bytes long
        char buf[20];
        
        for(int i = 0; i<%d; ++i) {
            sprintf(buf, "_res_sec_%%d", i);
            size_t sz;
            getsectiondata(&_mh_execute_header, "binary", buf, &sz);
            sizes[i] = sz;
        }
    }
    
    return sizes[id];
}

#endif
"""


def is_resource(filename):
    r = False
    for res in resources:
        if fnmatch.fnmatch(filename, res):
            r = True
            break
    return r


def get_var_name(file):
    return re.sub(r'[^A-Za-z0-9]', '_', file)


def process_resource(file):
    print("Processing %s" % file)

    name = get_var_name(file)
    varNames.append((name, file))


varNames = []

with open("resources.json") as data_file:
    config = json.load(data_file)
    resources = config["resources"]
    output = config["output"]
    project_name = config["project_name"]

    if os.path.exists(output):
        rmtree(output)

    if not os.path.exists(output):
        os.mkdir(output)
    if not os.path.exists(output + "/objs"):
        os.mkdir(output + "/objs")
    if not os.path.exists(output + "/include"):
        os.mkdir(output + "/include")
    if not os.path.exists(output + "/src"):
        os.mkdir(output + "/src")
    if not os.path.exists(output + "/temp"):
        os.mkdir(output + "/temp")
    if not os.path.exists(output + "/include/resource_builder"):
        os.mkdir(output + "/include/resource_builder")

    for dirName, subdirList, fileList in os.walk("."):
        for f in fileList:
            local_file = dirName + "/" + f
            if is_resource(local_file):
                process_resource(local_file)

    if sys.platform == "win32":
        with open("./build/src/win.rc", "w") as winFile:
            for var in varNames:
                path = var[1].replace("\\", "/")
                winFile.write("%s RCDATA \"./../../%s\"\n" % (var[0], path))
            winFile.close()
    elif sys.platform.startswith('linux'):
        for var in varNames:
            out_file = "%s/objs/%s.o" % (output, var[0])
            subprocess.call(["objcopy", "-I", "binary", "-O", "elf64-x86-64", "-B", "i386:x86-64", var[1], out_file])
    elif sys.platform.startswith('darwin'):
        # use approach from https://stackoverflow.com/a/13772389/7694893
        stub_src = "./build/temp/stub.c"
        stub_obj = "./build/temp/stub.o"
        open(stub_src, "w").close()
        subprocess.call(["gcc", "-o", stub_obj, "-c", stub_src])
        counter = 0
        for var in varNames:
            # section name is limited to 16 symbols, so up to 10,000,000 resources can be embedded (count from 0)
            mac_sect = "_res_sec_%d" % counter
            out_file = "%s/objs/%s.o" % (output, var[0])
            subprocess.call(["ld", "-r", "-o", out_file, "-sectcreate", "binary", mac_sect, var[1], stub_obj])
            counter += 1

    with open("./build/include/resource_builder/resources.h", "w") as header:
        ids = ""
        isFirst = True
        counter = 0
        for var in varNames:
            if not isFirst:
                # for second and other ids add comma, new line and 8 spaces
                ids += ",\n        "
            ids += "RES_%s = %d" % (var[0].upper(), counter)
            counter += 1
            isFirst = False
        header_def = project_name.upper()
        header.write(headerTemplate % (header_def, header_def, ids, header_def))
        header.close()

    with open("./build/src/resources.cpp", "w") as source:
        extern_vars = ""
        starts_arr = ""
        sizes_arr = ""
        names_arr = ""
        counter = 0
        isFirst = True
        for var in varNames:
            counter += 1
            start = "_binary_" + var[0] + "_start"
            end = "_binary_" + var[0] + "_end"
            if not isFirst:
                # spaces are for proper indentation
                starts_arr += ",\n                         "
                sizes_arr += ",\n                        "
                names_arr += ",\n                                  "
            isFirst = False

            extern_vars += "extern uint8_t " + start + ";\n"
            extern_vars += "extern uint8_t " + end + ";\n"
            starts_arr += "&" + start
            names_arr += "\"" + var[0] + "\""
            sizes_arr += "static_cast<uint32_t>(&" + end + " - &" + start + ")"

        source.write(sourceTemplate % (extern_vars, starts_arr, sizes_arr,
                                       names_arr, counter, counter, names_arr, counter, counter,
                                       counter, counter, counter, counter))
        source.close()
